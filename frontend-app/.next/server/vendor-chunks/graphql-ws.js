"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws";
exports.ids = ["vendor-chunks/graphql-ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphql-ws/lib/client.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/client.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */\n\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({ type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload\n                        ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload\n                                ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n                    _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID(payload);\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next: {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                            id,\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                    id,\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = this.subscribe(request, {\n                next(val) {\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJLDRCQUE0QjtBQUN2RCx3QkFBd0IsU0FBSSxJQUFJLFNBQUk7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ3NIO0FBQzdEO0FBQ3pEO0FBQzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWiwrQkFBK0I7QUFDL0Isd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNENBQTRDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixzRUFBNkI7QUFDekg7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCLEdBQUcsTUFBTSxvREFBVyxPQUFPO0FBQ25GO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUFnQjtBQUNoRDtBQUNBLGtDQUFrQyxvREFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQVc7QUFDN0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtEQUFTO0FBQ2xELHlCQUF5QjtBQUN6QjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQVMsc0JBQXNCLDREQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBLG9DQUFvQyx5REFBWTtBQUNoRDtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2REFBZ0I7QUFDeEQ7QUFDQSwwQ0FBMEMsb0RBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFXO0FBQ3JEO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5Q0FBeUMsb0RBQVc7QUFDcEQsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxzQ0FBc0M7QUFDdEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGlDQUFpQyxrREFBUyxjQUFjLDREQUFnQjtBQUN4RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0Isb0JBQW9CLGtEQUFTO0FBQzdCLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0I7QUFDQSxvQkFBb0Isa0RBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixrREFBUztBQUM3QixvQkFBb0Isa0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvREFBVztBQUNoRDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsb0NBQW9DLDZEQUFnQjtBQUNwRDtBQUNBLGtDQUFrQyxvREFBVztBQUM3QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkRBQWdCO0FBQzVEO0FBQ0EsMENBQTBDLG9EQUFXO0FBQ3JELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGF1bmRyeS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQubWpzPzljZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY2xpZW50XG4gKlxuICovXG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuaW1wb3J0IHsgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wsIENsb3NlQ29kZSwgTWVzc2FnZVR5cGUsIHBhcnNlTWVzc2FnZSwgc3RyaW5naWZ5TWVzc2FnZSwgfSBmcm9tICcuL2NvbW1vbi5tanMnO1xuaW1wb3J0IHsgaXNPYmplY3QsIGxpbWl0Q2xvc2VSZWFzb24gfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKiogVGhpcyBmaWxlIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYnJvd3NlcnMsIHJlLWV4cG9ydCBjb21tb24gZWxlbWVudHMuICovXG5leHBvcnQgKiBmcm9tICcuL2NvbW1vbi5tanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXJsLCBjb25uZWN0aW9uUGFyYW1zLCBsYXp5ID0gdHJ1ZSwgb25Ob25MYXp5RXJyb3IgPSBjb25zb2xlLmVycm9yLCBsYXp5Q2xvc2VUaW1lb3V0OiBsYXp5Q2xvc2VUaW1lb3V0TXMgPSAwLCBrZWVwQWxpdmUgPSAwLCBkaXNhYmxlUG9uZywgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID0gMCwgcmV0cnlBdHRlbXB0cyA9IDUsIHJldHJ5V2FpdCA9IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbWlzZWRFeHBvbmVudGlhbEJhY2tvZmYocmV0cmllcykge1xuICAgICAgICBsZXQgcmV0cnlEZWxheSA9IDEwMDA7IC8vIHN0YXJ0IHdpdGggMXMgZGVsYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5ICtcbiAgICAgICAgICAgIC8vIGFkZCByYW5kb20gdGltZW91dCBmcm9tIDMwMG1zIHRvIDNzXG4gICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMzAwMCAtIDMwMCkgKyAzMDApKSk7XG4gICAgfSwgc2hvdWxkUmV0cnkgPSBpc0xpa2VDbG9zZUV2ZW50LCBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0sIG9uLCB3ZWJTb2NrZXRJbXBsLCBcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2NCBVVUlEIHRvIGJlIHVzZWQgYXMgdGhlIElEIHVzaW5nIGBNYXRoYFxuICAgICAqIGFzIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gU3VwcGx5IHlvdXIgb3duIGdlbmVyYXRvclxuICAgICAqIGluIGNhc2UgeW91IG5lZWQgbW9yZSB1bmlxdWVuZXNzLlxuICAgICAqXG4gICAgICogUmVmZXJlbmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gICAgICovXG4gICAgZ2VuZXJhdGVJRCA9IGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgIH0sIGpzb25NZXNzYWdlUmVwbGFjZXI6IHJlcGxhY2VyLCBqc29uTWVzc2FnZVJldml2ZXI6IHJldml2ZXIsIH0gPSBvcHRpb25zO1xuICAgIGxldCB3cztcbiAgICBpZiAod2ViU29ja2V0SW1wbCkge1xuICAgICAgICBpZiAoIWlzV2ViU29ja2V0KHdlYlNvY2tldEltcGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgd3MgPSB3ZWJTb2NrZXRJbXBsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9IFdlYlNvY2tldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPVxuICAgICAgICAgICAgZ2xvYmFsLldlYlNvY2tldCB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFN1cHBvcnQgbW9yZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIHdpbmRvdy5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB3aW5kb3cuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBpZiAoIXdzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gbWlzc2luZzsgb24gTm9kZSB5b3UgY2FuIGBpbXBvcnQgV2ViU29ja2V0IGZyb20gJ3dzJztgIGFuZCBwYXNzIGB3ZWJTb2NrZXRJbXBsOiBXZWJTb2NrZXRgIHRvIGBjcmVhdGVDbGllbnRgXCIpO1xuICAgIGNvbnN0IFdlYlNvY2tldEltcGwgPSB3cztcbiAgICAvLyB3ZWJzb2NrZXQgc3RhdHVzIGVtaXR0ZXIsIHN1YnNjcmlwdGlvbnMgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHlcbiAgICBjb25zdCBlbWl0dGVyID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb24oaWQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpZF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1pdChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyc1ttZXNzYWdlLmlkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXJzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgY29ubmVjdGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0aW5nKSA/IFtvbi5jb25uZWN0aW5nXSA6IFtdLFxuICAgICAgICAgICAgb3BlbmVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLm9wZW5lZCkgPyBbb24ub3BlbmVkXSA6IFtdLFxuICAgICAgICAgICAgY29ubmVjdGVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNvbm5lY3RlZCkgPyBbb24uY29ubmVjdGVkXSA6IFtdLFxuICAgICAgICAgICAgcGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5waW5nKSA/IFtvbi5waW5nXSA6IFtdLFxuICAgICAgICAgICAgcG9uZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5wb25nKSA/IFtvbi5wb25nXSA6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5tZXNzYWdlKSA/IFttZXNzYWdlLmVtaXQsIG9uLm1lc3NhZ2VdIDogW21lc3NhZ2UuZW1pdF0sXG4gICAgICAgICAgICBjbG9zZWQ6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY2xvc2VkKSA/IFtvbi5jbG9zZWRdIDogW10sXG4gICAgICAgICAgICBlcnJvcjogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5lcnJvcikgPyBbb24uZXJyb3JdIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbk1lc3NhZ2U6IG1lc3NhZ2Uub24sXG4gICAgICAgICAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBsLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGwuc3BsaWNlKGwuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNvcHkgdGhlIGxpc3RlbmVycyBzbyB0aGF0IHVubGlzdGVucyBkb250IFwicHVsbCB0aGUgcnVnIHVuZGVyIG91ciBmZWV0XCJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi5saXN0ZW5lcnNbZXZlbnRdXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUaGUgYXJncyBzaG91bGQgZml0XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvLyBpbnZva2VzIHRoZSBjYWxsYmFjayBlaXRoZXIgd2hlbiBhbiBlcnJvciBvciBjbG9zZWQgZXZlbnQgaXMgZW1pdHRlZCxcbiAgICAvLyBmaXJzdCBvbmUgdGhhdCBnZXRzIGNhbGxlZCBwcmV2YWlscywgb3RoZXIgZW1pc3Npb25zIGFyZSBpZ25vcmVkXG4gICAgZnVuY3Rpb24gZXJyb3JPckNsb3NlZChjYikge1xuICAgICAgICBjb25zdCBsaXN0ZW5pbmcgPSBbXG4gICAgICAgICAgICAvLyBlcnJvcnMgYXJlIGZhdGFsIGFuZCBtb3JlIGNyaXRpY2FsIHRoYW4gY2xvc2UgZXZlbnRzLCB0aHJvdyB0aGVtIGZpcnN0XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5pbmcuZm9yRWFjaCgodW5saXN0ZW4pID0+IHVubGlzdGVuKCkpO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIGNsb3NlcyBjYW4gYmUgZ3JhY2VmdWwgYW5kIG5vdCBmYXRhbCwgdGhyb3cgdGhlbSBzZWNvbmQgKGlmIGVycm9yIGRpZG50IHRocm93KVxuICAgICAgICAgICAgZW1pdHRlci5vbignY2xvc2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGV0IGNvbm5lY3RpbmcsIGxvY2tzID0gMCwgbGF6eUNsb3NlVGltZW91dCwgcmV0cnlpbmcgPSBmYWxzZSwgcmV0cmllcyA9IDAsIGRpc3Bvc2VkID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGxhenkgY2xvc2UgdGltZW91dCBpbW1lZGlhdGVsbHkgc28gdGhhdCBjbG9zZSBnZXRzIGRlYm91bmNlZFxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9pc3N1ZXMvMzg4XG4gICAgICAgIGNsZWFyVGltZW91dChsYXp5Q2xvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IChjb25uZWN0aW5nICE9PSBudWxsICYmIGNvbm5lY3RpbmcgIT09IHZvaWQgMCA/IGNvbm5lY3RpbmcgOiAoY29ubmVjdGluZyA9IG5ldyBQcm9taXNlKChjb25uZWN0ZWQsIGRlbmllZCkgPT4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRyeWluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJldHJ5V2FpdChyZXRyaWVzKTtcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb25zIG1pZ2h0IGNvbXBsZXRlIHdoaWxlIHdhaXRpbmcgZm9yIHJldHJ5XG4gICAgICAgICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVuaWVkKHsgY29kZTogMTAwMCwgcmVhc29uOiAnQWxsIFN1YnNjcmlwdGlvbnMgR29uZScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldEltcGwodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHVybCgpIDogdXJsLCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCk7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFja1RpbWVvdXQsIHF1ZXVlZFBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlUGluZygpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoa2VlcEFsaXZlKSAmJiBrZWVwQWxpdmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTsgLy8gaW4gY2FzZSB3aGVyZSBhIHBvbmcgd2FzIHJlY2VpdmVkIGJlZm9yZSBhIHBpbmcgKHRoaXMgaXMgdmFsaWQgYmVoYXZpb3VyKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZWRQaW5nID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UoeyB0eXBlOiBNZXNzYWdlVHlwZS5QaW5nIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BpbmcnLCBmYWxzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwga2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvck9yQ2xvc2VkKChlcnJPckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChxdWV1ZWRQaW5nKTtcbiAgICAgICAgICAgICAgICBkZW5pZWQoZXJyT3JFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JFdmVudCkgJiYgZXJyT3JFdmVudC5jb2RlID09PSA0NDk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSg0NDk5LCAnVGVybWluYXRlZCcpOyAvLyBjbG9zZSBldmVudCBpcyBhcnRpZmljaWFsIGFuZCBlbWl0dGVkIG1hbnVhbGx5LCBzZWUgYENsaWVudC50ZXJtaW5hdGUoKWAgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IChlcnIpID0+IGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywgZXZlbnQpO1xuICAgICAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ29wZW5lZCcsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgY29ubmVjdGlvblBhcmFtcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBjb25uZWN0aW9uUGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvblBhcmFtcyBtaWdodCB0YWtlIHRvbyBsb25nIGNhdXNpbmcgdGhlIHNlcnZlciB0byBraWNrIG9mZiB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgZXJyb3IvY2xvc2UgZXZlbnQgaXMgYWxyZWFkeSByZXBvcnRlZCAtIHNpbXBseSBzdG9wIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZShwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpcyBjb21wbGV0ZWx5IGFic2VudCBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZShDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsICdDb25uZWN0aW9uIGFja25vd2xlZGdlbWVudCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb25uZWN0aW9uQWNrV2FpdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgcGluZyAobm9vcCBpZiBkaXNhYmxlZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5JbnRlcm5hbENsaWVudEVycm9yLCBsaW1pdENsb3NlUmVhc29uKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBuZXcgRXJyb3IoZXJyKS5tZXNzYWdlLCAnSW50ZXJuYWwgY2xpZW50IGVycm9yJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWNrbm93bGVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwaW5nJyB8fCBtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KG1lc3NhZ2UudHlwZSwgdHJ1ZSwgbWVzc2FnZS5wYXlsb2FkKTsgLy8gcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVQaW5nKCk7IC8vIGVucXVldWUgbmV4dCBwaW5nIChub29wIGlmIGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVQb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB3aXRoIHBvbmcgb24gcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2UobWVzc2FnZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwb25nJywgZmFsc2UsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHBpbmcgYW5kIHBvbmdzIGNhbiBiZSByZWNlaXZlZCB3aGVuZXZlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2tub3dsZWRnZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgY29ubmVjdGVkIGFuZCBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlyc3QgbWVzc2FnZSBjYW5ub3QgYmUgb2YgdHlwZSAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdjb25uZWN0ZWQnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCk7IC8vIGNvbm5lY3RlZCA9IHNvY2tldCBvcGVuZWQgKyBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlpbmcgPSBmYWxzZTsgLy8gZnV0dXJlIGxhenkgY29ubmVjdHMgYXJlIG5vdCByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXMgPSAwOyAvLyByZXNldCB0aGUgcmV0cmllcyBvbiBjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZChbXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBlcnJvck9yQ2xvc2VkKHJlamVjdCkpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gbnVsbDsgLy8gc3RvcCByZWFkaW5nIG1lc3NhZ2VzIGFzIHNvb24gYXMgcmVhZGluZyBicmVha3Mgb25jZVxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5CYWRSZXNwb25zZSwgbGltaXRDbG9zZVJlYXNvbihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogbmV3IEVycm9yKGVycikubWVzc2FnZSwgJ0JhZCByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpKSkpO1xuICAgICAgICAvLyBpZiB0aGUgcHJvdmlkZWQgc29ja2V0IGlzIGluIGEgY2xvc2luZyBzdGF0ZSwgd2FpdCBmb3IgdGhlIHRocm93IG9uIGNsb3NlXG4gICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5DTE9TSU5HKVxuICAgICAgICAgICAgYXdhaXQgdGhyb3dPbkNsb3NlO1xuICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlbGVhc2VzIHRoaXMgY29ubmVjdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVsZWFzZSA9IHJlc29sdmUpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIHJlbGVhc2UsXG4gICAgICAgICAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yXG4gICAgICAgICAgICAgICAgcmVsZWFzZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBubyBtb3JlIGxvY2tzIGFyZSBwcmVzZW50LCBjb21wbGV0ZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiBzb2NrZXQuY2xvc2UoMTAwMCwgJ05vcm1hbCBDbG9zdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUobGF6eUNsb3NlVGltZW91dE1zKSAmJiBsYXp5Q2xvc2VUaW1lb3V0TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGtlZXBhbGl2ZSBpcyBzZXQsIGFsbG93IGZvciB0aGUgc3BlY2lmaWVkIGNhbG1kb3duIHRpbWUgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBjb21wbGV0ZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIG9wZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF6eUNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGF6eUNsb3NlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjb21wbGV0ZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvLyBvclxuICAgICAgICAgICAgICAgIHRocm93T25DbG9zZSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGBjb25uZWN0YCBwcm9ibGVtIGFuZCBldmFsdWF0ZXMgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgLy8gc29tZSBjbG9zZSBjb2RlcyBhcmUgd29ydGggcmVwb3J0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiZcbiAgICAgICAgICAgIChpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoZXJyT3JDbG9zZUV2ZW50LmNvZGUpIHx8XG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkludGVybmFsQ2xpZW50RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5CYWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQmFkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5VbmF1dGhvcml6ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Gb3JiaWRkZW4sIG1pZ2h0IGdyYW50IGFjY2VzcyBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuU3Vic2NyaWJlckFscmVhZHlFeGlzdHMsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5Ub29NYW55SW5pdGlhbGlzYXRpb25SZXF1ZXN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gNDQ5OSwgLy8gVGVybWluYXRlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgc29ja2V0IGZyb3plLCB3ZSB3YW50IHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnJPckNsb3NlRXZlbnQuY29kZSkpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBjbGllbnQgd2FzIGRpc3Bvc2VkLCBubyByZXRyaWVzIHNob3VsZCBwcm9jZWVkIHJlZ2FyZGxlc3NcbiAgICAgICAgaWYgKGRpc3Bvc2VkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBub3JtYWwgY2xvc3VyZSAocG9zc2libHkgYWxsIHN1YnNjcmlwdGlvbnMgaGF2ZSBjb21wbGV0ZWQpXG4gICAgICAgIC8vIGlmIG5vIGxvY2tzIHdlcmUgYWNxdWlyZWQgaW4gdGhlIG1lYW50aW1lLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJiBlcnJPckNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBsb2NrcyA+IDA7XG4gICAgICAgIC8vIHJldHJpZXMgYXJlIG5vdCBhbGxvd2VkIG9yIHdlIHRyaWVkIHRvIG1hbnkgdGltZXMsIHJlcG9ydCBlcnJvclxuICAgICAgICBpZiAoIXJldHJ5QXR0ZW1wdHMgfHwgcmV0cmllcyA+PSByZXRyeUF0dGVtcHRzKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyB0aHJvdyBub24tcmV0cnlhYmxlIGNvbm5lY3Rpb24gcHJvYmxlbXNcbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBAZGVwcmVjYXRlZCB0aHJvdyBmYXRhbCBjb25uZWN0aW9uIHByb2JsZW1zIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0gPT09IG51bGwgfHwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0oZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gbG9va3MgZ29vZCwgc3RhcnQgcmV0cnlpbmdcbiAgICAgICAgcmV0dXJuIChyZXRyeWluZyA9IHRydWUpO1xuICAgIH1cbiAgICAvLyBpbiBub24tbGF6eSAoaG90PykgbW9kZSBhbHdheXMgaG9sZCBvbmUgY29ubmVjdGlvbiBsb2NrIHRvIHBlcnNpc3QgdGhlIHNvY2tldFxuICAgIGlmICghbGF6eSkge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCAsIHRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTsgLy8gd2lsbCBhbHdheXMgdGhyb3cgYmVjYXVzZSByZWxlYXNlciBpcyBub3QgdXNlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHRocm93biBlcnJvciwgbm8gZnVydGhlciByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25Ob25MYXp5RXJyb3IgPT09IG51bGwgfHwgb25Ob25MYXp5RXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTm9uTGF6eUVycm9yKGVyck9yQ2xvc2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9uOiBlbWl0dGVyLm9uLFxuICAgICAgICBzdWJzY3JpYmUocGF5bG9hZCwgc2luaykge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlEKHBheWxvYWQpO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZSwgZXJyb3JlZCA9IGZhbHNlLCByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgaGFuZGxpbmcgY29tcGxldGlvbnMgYmVmb3JlIGNvbm5lY3RcbiAgICAgICAgICAgICAgICBsb2Nrcy0tO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0LCByZWxlYXNlLCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGRvbmUgd2hpbGUgd2FpdGluZyBmb3IgY29ubmVjdCwgcmVsZWFzZSB0aGUgY29ubmVjdGlvbiBsb2NrIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmxpc3RlbiA9IGVtaXR0ZXIub25NZXNzYWdlKGlkLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gcGF5bG9hZCB3aWxsIGZpdCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLm5leHQobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3JlZCA9IHRydWUpLCAoZG9uZSA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5lcnJvcihtZXNzYWdlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7IC8vIHJlbGVhc2UgY29tcGxldGVzIHRoZSBzaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgY29tcGxldGVkIGFscmVhZHkgYW5kIHNvY2tldCBpcyBvcGVuLCBzZW5kIGNvbXBsZXRlIG1lc3NhZ2UgdG8gc2VydmVyIG9uIHJlbGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGUgcmVsZWFzZXIgd2lsbCBiZSBjYWxsZWQsIGNvbm5lY3Rpb24gY29tcGxldGVkIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb21pc2UgcmVzb2x2ZWQgb3IgdGhlIHNvY2tldCBjbG9zZWQgYW5kIHRoZSBwcm9taXNlIHJlamVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgaGFwcGVucyB0aG91Z2gsIHdlIHdhbnQgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlLmZpbmFsbHkodW5saXN0ZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjb21wbGV0ZWQsIHNob3VsZG50IHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZGVsaXZlcmluZyBlaXRoZXIgYW4gZXJyb3Igb3IgYSBjb21wbGV0ZSB0ZXJtaW5hdGVzIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIGlmICghZXJyb3JlZClcbiAgICAgICAgICAgICAgICAgICAgc2luay5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSkgLy8gcmVzb2x2ZXMgb24gcmVsZWFzZSBvciBub3JtYWwgY2xvc3VyZVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSk7IC8vIHJlamVjdHMgb24gY2xvc2UgZXZlbnRzIGFuZCBlcnJvcnNcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZGlzcG9zZSBvbmx5IG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlcmF0ZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3Bvc2UgPSB0aGlzLnN1YnNjcmliZShyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gKGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGl0ZXJhdG9yXzEoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdhaXQgaWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbWVzc2FnZXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgZmx1c2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwZW5kaW5nLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmVycmVkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVmZXJyZWQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmVycmVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX19hd2FpdCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgaXRlcmF0b3IudGhyb3cgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICAgICAgZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb24sIGNsb3NlIGl0XG4gICAgICAgICAgICAgICAgY29uc3QgW3NvY2tldF0gPSBhd2FpdCBjb25uZWN0aW5nO1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgxMDAwLCAnTm9ybWFsIENsb3N1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGVybWluYXRlKCkge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY2xvc2VkJywge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0NDk5LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246ICdUZXJtaW5hdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgd2FzQ2xlYW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBpc0xpa2VDbG9zZUV2ZW50KHZhbCkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmICdjb2RlJyBpbiB2YWwgJiYgJ3JlYXNvbicgaW4gdmFsO1xufVxuZnVuY3Rpb24gaXNGYXRhbEludGVybmFsQ2xvc2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoW1xuICAgICAgICAxMDAwLFxuICAgICAgICAxMDAxLFxuICAgICAgICAxMDA2LFxuICAgICAgICAxMDA1LFxuICAgICAgICAxMDEyLFxuICAgICAgICAxMDEzLFxuICAgICAgICAxMDEzLCAvLyBCYWQgR2F0ZXdheVxuICAgIF0uaW5jbHVkZXMoY29kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBhbGwgb3RoZXIgaW50ZXJuYWwgZXJyb3JzIGFyZSBmYXRhbFxuICAgIHJldHVybiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSAxOTk5O1xufVxuZnVuY3Rpb24gaXNXZWJTb2NrZXQodmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICdjb25zdHJ1Y3RvcicgaW4gdmFsICYmXG4gICAgICAgICdDTE9TRUQnIGluIHZhbCAmJlxuICAgICAgICAnQ0xPU0lORycgaW4gdmFsICYmXG4gICAgICAgICdDT05ORUNUSU5HJyBpbiB2YWwgJiZcbiAgICAgICAgJ09QRU4nIGluIHZhbCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/common.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/common.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * common\n *\n */\n\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== 'string') {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            if (typeof val.payload.query !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */\nfunction isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY29tbW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyxvREFBUTtBQUNqQix3RUFBd0UsMERBQWMsTUFBTTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBEQUFjLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFRO0FBQ2hELG9DQUFvQyxTQUFTLDJGQUEyRixZQUFZO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsMERBQWMsU0FBUztBQUNsSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQSxpQkFBaUIsb0RBQVE7QUFDekIsb0NBQW9DLFNBQVMsb0VBQW9FLDBEQUFjLGNBQWM7QUFDN0k7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLHlFQUF5RSwwREFBYyxvQkFBb0I7QUFDeEo7QUFDQSxrREFBa0Qsb0RBQVE7QUFDMUQsb0NBQW9DLFNBQVMsc0dBQXNHLDBEQUFjLHdCQUF3QjtBQUN6TDtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFjO0FBQzlCLG9DQUFvQyxTQUFTLHVHQUF1RywwREFBYyw0QkFBNEI7QUFDOUw7QUFDQSxtREFBbUQsb0RBQVE7QUFDM0Qsb0NBQW9DLFNBQVMsdUdBQXVHLDBEQUFjLHlCQUF5QjtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsOERBQThELDBEQUFjLFNBQVM7QUFDbEk7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0EsaUJBQWlCLG9EQUFRO0FBQ3pCLG9DQUFvQyxTQUFTLG9FQUFvRSwwREFBYyxjQUFjO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyw4REFBOEQsMERBQWMsU0FBUztBQUNsSTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQSxpQkFBaUIsNERBQWdCO0FBQ2pDLG9DQUFvQyxTQUFTLHFGQUFxRiw0QkFBNEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLDhEQUE4RCwwREFBYyxTQUFTO0FBQ2xJO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhdW5kcnktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY29tbW9uLm1qcz9lZTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIGNvbW1vblxuICpcbiAqL1xuaW1wb3J0IHsgYXJlR3JhcGhRTEVycm9ycywgZXh0ZW5kZWRUeXBlb2YsIGlzT2JqZWN0IH0gZnJvbSAnLi91dGlscy5tanMnO1xuLyoqXG4gKiBUaGUgV2ViU29ja2V0IHN1Yi1wcm90b2NvbCB1c2VkIGZvciB0aGUgW0dyYXBoUUwgb3ZlciBXZWJTb2NrZXQgUHJvdG9jb2xdKGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtb3Zlci1odHRwL2Jsb2IvbWFpbi9yZmNzL0dyYXBoUUxPdmVyV2ViU29ja2V0Lm1kKS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBjb25zdCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCA9ICdncmFwaHFsLXRyYW5zcG9ydC13cyc7XG4vKipcbiAqIFRoZSBkZXByZWNhdGVkIHN1YnByb3RvY29sIHVzZWQgYnkgW3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzXShodHRwczovL2dpdGh1Yi5jb20vYXBvbGxvZ3JhcGhxbC9zdWJzY3JpcHRpb25zLXRyYW5zcG9ydC13cykuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IERFUFJFQ0FURURfR1JBUEhRTF9XU19QUk9UT0NPTCA9ICdncmFwaHFsLXdzJztcbi8qKlxuICogYGdyYXBocWwtd3NgIGV4cGVjdGVkIGFuZCBzdGFuZGFyZCBjbG9zZSBjb2RlcyBvZiB0aGUgW0dyYXBoUUwgb3ZlciBXZWJTb2NrZXQgUHJvdG9jb2xdKGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtb3Zlci1odHRwL2Jsb2IvbWFpbi9yZmNzL0dyYXBoUUxPdmVyV2ViU29ja2V0Lm1kKS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCB2YXIgQ2xvc2VDb2RlO1xuKGZ1bmN0aW9uIChDbG9zZUNvZGUpIHtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDQ1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkludGVybmFsQ2xpZW50RXJyb3JcIl0gPSA0MDA1XSA9IFwiSW50ZXJuYWxDbGllbnRFcnJvclwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXF1ZXN0XCJdID0gNDQwMF0gPSBcIkJhZFJlcXVlc3RcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQmFkUmVzcG9uc2VcIl0gPSA0MDA0XSA9IFwiQmFkUmVzcG9uc2VcIjtcbiAgICAvKiogVHJpZWQgc3Vic2NyaWJpbmcgYmVmb3JlIGNvbm5lY3QgYWNrICovXG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlVuYXV0aG9yaXplZFwiXSA9IDQ0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiRm9yYmlkZGVuXCJdID0gNDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIl0gPSA0NDA2XSA9IFwiU3VicHJvdG9jb2xOb3RBY2NlcHRhYmxlXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXRcIl0gPSA0NDA4XSA9IFwiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJDb25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dFwiXSA9IDQ1MDRdID0gXCJDb25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dFwiO1xuICAgIC8qKiBTdWJzY3JpYmVyIGRpc3RpbmN0aW9uIGlzIHZlcnkgaW1wb3J0YW50ICovXG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCJdID0gNDQwOV0gPSBcIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCJdID0gNDQyOV0gPSBcIlRvb01hbnlJbml0aWFsaXNhdGlvblJlcXVlc3RzXCI7XG59KShDbG9zZUNvZGUgfHwgKENsb3NlQ29kZSA9IHt9KSk7XG4vKipcbiAqIFR5cGVzIG9mIG1lc3NhZ2VzIGFsbG93ZWQgdG8gYmUgc2VudCBieSB0aGUgY2xpZW50L3NlcnZlciBvdmVyIHRoZSBXUyBwcm90b2NvbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCB2YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbXCJDb25uZWN0aW9uSW5pdFwiXSA9IFwiY29ubmVjdGlvbl9pbml0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDb25uZWN0aW9uQWNrXCJdID0gXCJjb25uZWN0aW9uX2Fja1wiO1xuICAgIE1lc3NhZ2VUeXBlW1wiUGluZ1wiXSA9IFwicGluZ1wiO1xuICAgIE1lc3NhZ2VUeXBlW1wiUG9uZ1wiXSA9IFwicG9uZ1wiO1xuICAgIE1lc3NhZ2VUeXBlW1wiU3Vic2NyaWJlXCJdID0gXCJzdWJzY3JpYmVcIjtcbiAgICBNZXNzYWdlVHlwZVtcIk5leHRcIl0gPSBcIm5leHRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiQ29tcGxldGVcIl0gPSBcImNvbXBsZXRlXCI7XG59KShNZXNzYWdlVHlwZSB8fCAoTWVzc2FnZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG1lc3NhZ2UgYWdhaW5zdCB0aGUgR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbC5cbiAqXG4gKiBJbnZhbGlkIG1lc3NhZ2VzIHdpbGwgdGhyb3cgZGVzY3JpcHRpdmUgZXJyb3JzLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZSh2YWwpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbCl9YCk7XG4gICAgfVxuICAgIGlmICghdmFsLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGlzIG1pc3NpbmcgdGhlICd0eXBlJyBwcm9wZXJ0eWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0cyB0aGUgJ3R5cGUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnR5cGUpfWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbC50eXBlKSB7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkluaXQ6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ29ubmVjdGlvbkFjazpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QaW5nOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBvbmc6IHtcbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZCAhPSBudWxsICYmICFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290IFwiJHt2YWwucGF5bG9hZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TdWJzY3JpYmU6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCh2YWwucGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdwYXlsb2FkJyBwcm9wZXJ0eSB0byBiZSBhbiBvYmplY3QsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5wYXlsb2FkLnF1ZXJ5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcGF5bG9hZCBleHBlY3RzIHRoZSAncXVlcnknIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQucXVlcnkpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLnZhcmlhYmxlcyAhPSBudWxsICYmICFpc09iamVjdCh2YWwucGF5bG9hZC52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICd2YXJpYWJsZXMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLnZhcmlhYmxlcyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQub3BlcmF0aW9uTmFtZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdvcGVyYXRpb25OYW1lJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZyBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5leHRlbnNpb25zICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdleHRlbnNpb25zJyBwcm9wZXJ0eSB0byBiZSBhIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5leHRlbnNpb25zKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRXJyb3I6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ2lkJyBwcm9wZXJ0eSB0byBiZSBhIHN0cmluZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbC5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgcmVxdWlyZXMgYSBub24tZW1wdHkgJ2lkJyBwcm9wZXJ0eWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcmVHcmFwaFFMRXJyb3JzKHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIGFycmF5IG9mIEdyYXBoUUwgZXJyb3JzLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db21wbGV0ZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgJ3R5cGUnIHByb3BlcnR5IFwiJHt2YWwudHlwZX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgdmFsaWQgR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBtZXNzYWdlLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgdmFsaWRhdGVNZXNzYWdlYCBpbnN0ZWFkLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWVzc2FnZSh2YWwpIHtcbiAgICB0cnkge1xuICAgICAgICB2YWxpZGF0ZU1lc3NhZ2UodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZXMgdGhlIHJhdyB3ZWJzb2NrZXQgbWVzc2FnZSBkYXRhIHRvIGEgdmFsaWQgbWVzc2FnZS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1lc3NhZ2UoZGF0YSwgcmV2aXZlcikge1xuICAgIHJldHVybiB2YWxpZGF0ZU1lc3NhZ2UodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShkYXRhLCByZXZpdmVyKSA6IGRhdGEpO1xufVxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHZhbGlkIG1lc3NhZ2UgcmVhZHkgdG8gYmUgc2VudCB0aHJvdWdoIHRoZSBzb2NrZXQuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5TWVzc2FnZShtc2csIHJlcGxhY2VyKSB7XG4gICAgdmFsaWRhdGVNZXNzYWdlKG1zZyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1zZywgcmVwbGFjZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/common.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/utils.mjs":
/*!***********************************************!*\
  !*** ./node_modules/graphql-ws/lib/utils.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nfunction isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhdW5kcnktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvdXRpbHMubWpzPzkxMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kZWRUeXBlb2YodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbDtcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBleHRlbmRlZFR5cGVvZih2YWwpID09PSAnb2JqZWN0Jztcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3IodmFsKSB7XG4gICAgcmV0dXJuIChpc09iamVjdCh2YWwpICYmXG4gICAgICAgIHR5cGVvZiBPYmplY3QodmFsKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbC5yZXR1cm4gPT09ICdmdW5jdGlvbidcbiAgICAvLyBmb3IgbGF6eSBvbmVzLCB3ZSBvbmx5IG5lZWQgdGhlIHJldHVybiBhbnl3YXlcbiAgICAvLyB0eXBlb2YgdmFsLnRocm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gdHlwZW9mIHZhbC5uZXh0ID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbn1cbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZUdyYXBoUUxFcnJvcnMob2JqKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAgICAgLy8gbXVzdCBiZSBhdCBsZWFzdCBvbmUgZXJyb3JcbiAgICAgICAgb2JqLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgLy8gZXJyb3IgaGFzIGF0IGxlYXN0IGEgbWVzc2FnZVxuICAgICAgICBvYmouZXZlcnkoKG9iKSA9PiAnbWVzc2FnZScgaW4gb2IpKTtcbn1cbi8qKlxuICogTGltaXRzIHRoZSBXZWJTb2NrZXQgY2xvc2UgZXZlbnQgcmVhc29uIHRvIG5vdCBleGNlZWQgYSBsZW5ndGggb2Ygb25lIGZyYW1lLlxuICogUmVmZXJlbmNlOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0Q2xvc2VSZWFzb24ocmVhc29uLCB3aGVuVG9vTG9uZykge1xuICAgIHJldHVybiByZWFzb24ubGVuZ3RoIDwgMTI0ID8gcmVhc29uIDogd2hlblRvb0xvbmc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/utils.mjs\n");

/***/ })

};
;