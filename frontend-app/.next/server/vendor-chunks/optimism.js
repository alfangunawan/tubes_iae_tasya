"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/optimism";
exports.ids = ["vendor-chunks/optimism"];
exports.modules = {

/***/ "(ssr)/./node_modules/optimism/lib/bundle.cjs":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/bundle.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar trie = __webpack_require__(/*! @wry/trie */ \"(ssr)/./node_modules/@wry/trie/lib/bundle.cjs\");\nvar caches$1 = __webpack_require__(/*! @wry/caches */ \"(ssr)/./node_modules/@wry/caches/lib/bundle.cjs\");\nvar context = __webpack_require__(/*! @wry/context */ \"(ssr)/./node_modules/@wry/context/lib/bundle.cjs\");\n\nvar parentEntrySlot = new context.Slot();\nfunction nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar arrayFromSet = Array.from ||\n    function (set) {\n        var array = [];\n        set.forEach(function (item) { return array.push(item); });\n        return array;\n    };\nfunction maybeUnsubscribe(entryOrDep) {\n    var unsubscribe = entryOrDep.unsubscribe;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n\nvar emptySetPool = [];\nvar POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    var len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nvar Entry = /** @class */ (function () {\n    function Entry(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    Entry.prototype.peek = function () {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    };\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    Entry.prototype.recompute = function (args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    };\n    Entry.prototype.setDirty = function () {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        maybeUnsubscribe(this);\n    };\n    Entry.prototype.dispose = function () {\n        var _this = this;\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, function (parent, child) {\n            parent.setDirty();\n            forgetChild(parent, _this);\n        });\n    };\n    Entry.prototype.forget = function () {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    };\n    Entry.prototype.dependOn = function (dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    };\n    Entry.prototype.forgetDeps = function () {\n        var _this = this;\n        if (this.deps) {\n            arrayFromSet(this.deps).forEach(function (dep) { return dep.delete(_this); });\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    };\n    Entry.count = 0;\n    return Entry;\n}());\nfunction rememberParent(child) {\n    var parent = parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    var normalizeResult = entry.normalizeResult;\n    var oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    var parentCount = child.parents.size;\n    if (parentCount) {\n        var parents = arrayFromSet(child.parents);\n        for (var i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    var parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    var childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    var dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach(function (_value, child) {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n\nvar EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nfunction dep(options) {\n    var depsByKey = new Map();\n    var subscribe = options && options.subscribe;\n    function depend(key) {\n        var parent = parentEntrySlot.getValue();\n        if (parent) {\n            var dep_1 = depsByKey.get(key);\n            if (!dep_1) {\n                depsByKey.set(key, dep_1 = new Set);\n            }\n            parent.dependOn(dep_1);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep_1);\n                dep_1.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        var dep = depsByKey.get(key);\n        if (dep) {\n            var m_1 = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(function (entry) { return entry[m_1](); });\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nvar defaultKeyTrie;\nfunction defaultMakeCacheKey() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var trie$1 = defaultKeyTrie || (defaultKeyTrie = new trie.Trie(typeof WeakMap === \"function\"));\n    return trie$1.lookupArray(args);\n}\nvar caches = new Set();\nfunction wrap(originalFunction, _a) {\n    var _b = _a === void 0 ? Object.create(null) : _a, _c = _b.max, max = _c === void 0 ? Math.pow(2, 16) : _c, keyArgs = _b.keyArgs, _d = _b.makeCacheKey, makeCacheKey = _d === void 0 ? defaultMakeCacheKey : _d, normalizeResult = _b.normalizeResult, subscribe = _b.subscribe, _e = _b.cache, cacheOption = _e === void 0 ? caches$1.StrongCache : _e;\n    var cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, function (entry) { return entry.dispose(); })\n        : cacheOption;\n    var optimistic = function () {\n        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        var entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = function () { return cache.delete(key); };\n        }\n        var value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!parentEntrySlot.hasValue()) {\n            caches.forEach(function (cache) { return cache.clean(); });\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: function () { return cache.size; },\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max: max,\n        keyArgs: keyArgs,\n        makeCacheKey: makeCacheKey,\n        normalizeResult: normalizeResult,\n        subscribe: subscribe,\n        cache: cache,\n    });\n    function dirtyKey(key) {\n        var entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        var entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n\nObject.defineProperty(exports, \"KeyTrie\", ({\n    enumerable: true,\n    get: function () { return trie.Trie; }\n}));\nObject.defineProperty(exports, \"Slot\", ({\n    enumerable: true,\n    get: function () { return context.Slot; }\n}));\nObject.defineProperty(exports, \"asyncFromGen\", ({\n    enumerable: true,\n    get: function () { return context.asyncFromGen; }\n}));\nObject.defineProperty(exports, \"bindContext\", ({\n    enumerable: true,\n    get: function () { return context.bind; }\n}));\nObject.defineProperty(exports, \"noContext\", ({\n    enumerable: true,\n    get: function () { return context.noContext; }\n}));\nObject.defineProperty(exports, \"setTimeout\", ({\n    enumerable: true,\n    get: function () { return context.setTimeout; }\n}));\nexports.defaultMakeCacheKey = defaultMakeCacheKey;\nexports.dep = dep;\nexports.nonReactive = nonReactive;\nexports.wrap = wrap;\n//# sourceMappingURL=bundle.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3B0aW1pc20vbGliL2J1bmRsZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGdFQUFXO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQyxjQUFjLG1CQUFPLENBQUMsc0VBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQ0FBMEM7QUFDMUM7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUMsRUFBQztBQUNGLGdEQUErQztBQUMvQztBQUNBLHVCQUF1QjtBQUN2QixDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBLHVCQUF1QjtBQUN2QixDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0IsV0FBVztBQUNYLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXVuZHJ5LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wdGltaXNtL2xpYi9idW5kbGUuY2pzPzU4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJpZSA9IHJlcXVpcmUoJ0B3cnkvdHJpZScpO1xudmFyIGNhY2hlcyQxID0gcmVxdWlyZSgnQHdyeS9jYWNoZXMnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnQHdyeS9jb250ZXh0Jyk7XG5cbnZhciBwYXJlbnRFbnRyeVNsb3QgPSBuZXcgY29udGV4dC5TbG90KCk7XG5mdW5jdGlvbiBub25SZWFjdGl2ZShmbikge1xuICAgIHJldHVybiBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKHZvaWQgMCwgZm4pO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGFycmF5RnJvbVNldCA9IEFycmF5LmZyb20gfHxcbiAgICBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYXJyYXkucHVzaChpdGVtKTsgfSk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuZnVuY3Rpb24gbWF5YmVVbnN1YnNjcmliZShlbnRyeU9yRGVwKSB7XG4gICAgdmFyIHVuc3Vic2NyaWJlID0gZW50cnlPckRlcC51bnN1YnNjcmliZTtcbiAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50cnlPckRlcC51bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5cbnZhciBlbXB0eVNldFBvb2wgPSBbXTtcbnZhciBQT09MX1RBUkdFVF9TSVpFID0gMTAwO1xuLy8gU2luY2UgdGhpcyBwYWNrYWdlIG1pZ2h0IGJlIHVzZWQgYnJvd3NlcnMsIHdlIHNob3VsZCBhdm9pZCB1c2luZyB0aGVcbi8vIE5vZGUgYnVpbHQtaW4gYXNzZXJ0IG1vZHVsZS5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG9wdGlvbmFsTWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25hbE1lc3NhZ2UgfHwgXCJhc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUlzKGEsIGIpIHtcbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gICAgcmV0dXJuIChcbiAgICAvLyBVbmtub3duIHZhbHVlcyBhcmUgbm90IGVxdWFsIHRvIGVhY2ggb3RoZXIuXG4gICAgbGVuID4gMCAmJlxuICAgICAgICAvLyBCb3RoIHZhbHVlcyBtdXN0IGJlIG9yZGluYXJ5IChvciBib3RoIGV4Y2VwdGlvbmFsKSB0byBiZSBlcXVhbC5cbiAgICAgICAgbGVuID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAvLyBUaGUgdW5kZXJseWluZyB2YWx1ZSBvciBleGNlcHRpb24gbXVzdCBiZSB0aGUgc2FtZS5cbiAgICAgICAgYVtsZW4gLSAxXSA9PT0gYltsZW4gLSAxXSk7XG59XG5mdW5jdGlvbiB2YWx1ZUdldCh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZVwiKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gdmFsdWVbMF07XG4gICAgICAgIGNhc2UgMjogdGhyb3cgdmFsdWVbMV07XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsdWVDb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKDApO1xufVxudmFyIEVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudHJ5KGZuKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5wYXJlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGVuIHRoaXMgRW50cnkgaGFzIGNoaWxkcmVuIHRoYXQgYXJlIGRpcnR5LCB0aGlzIHByb3BlcnR5IGJlY29tZXNcbiAgICAgICAgLy8gYSBTZXQgY29udGFpbmluZyBvdGhlciBFbnRyeSBvYmplY3RzLCBib3Jyb3dlZCBmcm9tIGVtcHR5U2V0UG9vbC5cbiAgICAgICAgLy8gV2hlbiB0aGUgc2V0IGJlY29tZXMgZW1wdHksIGl0IGdldHMgcmVjeWNsZWQgYmFjayB0byBlbXB0eVNldFBvb2wuXG4gICAgICAgIHRoaXMuZGlydHlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29tcHV0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBzID0gbnVsbDtcbiAgICAgICAgKytFbnRyeS5jb3VudDtcbiAgICB9XG4gICAgRW50cnkucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiAhbWlnaHRCZURpcnR5KHRoaXMpKSB7XG4gICAgICAgICAgICByZW1lbWJlclBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBtZXRob2Qgb2YgdGhlIEVudHJ5IEFQSSwgYmVjYXVzZSBpdFxuICAgIC8vIGRldGVybWluZXMgd2hldGhlciB0aGUgY2FjaGVkIHRoaXMudmFsdWUgY2FuIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5LFxuICAgIC8vIG9yIG11c3QgYmUgcmVjb21wdXRlZC4gVGhlIG92ZXJhbGwgcGVyZm9ybWFuY2Ugb2YgdGhlIGNhY2hpbmcgc3lzdGVtXG4gICAgLy8gZGVwZW5kcyBvbiB0aGUgdHJ1dGggb2YgdGhlIGZvbGxvd2luZyBvYnNlcnZhdGlvbnM6ICgxKSB0aGlzLmRpcnR5IGlzXG4gICAgLy8gdXN1YWxseSBmYWxzZSwgKDIpIHRoaXMuZGlydHlDaGlsZHJlbiBpcyB1c3VhbGx5IG51bGwvZW1wdHksIGFuZCB0aHVzXG4gICAgLy8gKDMpIHZhbHVlR2V0KHRoaXMudmFsdWUpIGlzIHVzdWFsbHkgcmV0dXJuZWQgd2l0aG91dCByZWNvbXB1dGF0aW9uLlxuICAgIEVudHJ5LnByb3RvdHlwZS5yZWNvbXB1dGUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICBhc3NlcnQoIXRoaXMucmVjb21wdXRpbmcsIFwiYWxyZWFkeSByZWNvbXB1dGluZ1wiKTtcbiAgICAgICAgcmVtZW1iZXJQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBtaWdodEJlRGlydHkodGhpcylcbiAgICAgICAgICAgID8gcmVhbGx5UmVjb21wdXRlKHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICA6IHZhbHVlR2V0KHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgRW50cnkucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHJlcG9ydERpcnR5KHRoaXMpO1xuICAgICAgICAvLyBXZSBjYW4gZ28gYWhlYWQgYW5kIHVuc3Vic2NyaWJlIGhlcmUsIHNpbmNlIGFueSBmdXJ0aGVyIGRpcnR5XG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbnMgd2UgcmVjZWl2ZSB3aWxsIGJlIHJlZHVuZGFudCwgYW5kIHVuc3Vic2NyaWJpbmcgbWF5XG4gICAgICAgIC8vIGZyZWUgdXAgc29tZSByZXNvdXJjZXMsIGUuZy4gZmlsZSB3YXRjaGVycy5cbiAgICAgICAgbWF5YmVVbnN1YnNjcmliZSh0aGlzKTtcbiAgICB9O1xuICAgIEVudHJ5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldERpcnR5KCk7XG4gICAgICAgIC8vIFNldmVyIGFueSBkZXBlbmRlbmN5IHJlbGF0aW9uc2hpcHMgd2l0aCBvdXIgb3duIGNoaWxkcmVuLCBzbyB0aG9zZVxuICAgICAgICAvLyBjaGlsZHJlbiBkb24ndCByZXRhaW4gdGhpcyBwYXJlbnQgRW50cnkgaW4gdGhlaXIgY2hpbGQucGFyZW50cyBzZXRzLFxuICAgICAgICAvLyB0aGVyZWJ5IHByZXZlbnRpbmcgaXQgZnJvbSBiZWluZyBmdWxseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgZm9yZ2V0Q2hpbGRyZW4odGhpcyk7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBlbnRyeSBoYXMgYmVlbiBraWNrZWQgb3V0IG9mIHRoZSBjYWNoZSAoaW4gaW5kZXguanMpLFxuICAgICAgICAvLyB3ZSd2ZSBsb3N0IHRoZSBhYmlsaXR5IHRvIGZpbmQgb3V0IGlmL3doZW4gdGhpcyBlbnRyeSBiZWNvbWVzIGRpcnR5LFxuICAgICAgICAvLyB3aGV0aGVyIHRoYXQgaGFwcGVucyB0aHJvdWdoIGEgc3Vic2NyaXB0aW9uLCBiZWNhdXNlIG9mIGEgZGlyZWN0IGNhbGxcbiAgICAgICAgLy8gdG8gZW50cnkuc2V0RGlydHkoKSwgb3IgYmVjYXVzZSBvbmUgb2YgaXRzIGNoaWxkcmVuIGJlY29tZXMgZGlydHkuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBsb3NzIG9mIGZ1dHVyZSBpbmZvcm1hdGlvbiwgd2UgaGF2ZSB0byBhc3N1bWUgdGhlXG4gICAgICAgIC8vIHdvcnN0ICh0aGF0IHRoaXMgZW50cnkgbWlnaHQgaGF2ZSBiZWNvbWUgZGlydHkgdmVyeSBzb29uKSwgc28gd2UgbXVzdFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBtYXJrIHRoaXMgZW50cnkncyBwYXJlbnRzIGFzIGRpcnR5LiBOb3JtYWxseSB3ZSBjb3VsZFxuICAgICAgICAvLyBqdXN0IGNhbGwgZW50cnkuc2V0RGlydHkoKSByYXRoZXIgdGhhbiBjYWxsaW5nIHBhcmVudC5zZXREaXJ0eSgpIGZvclxuICAgICAgICAvLyBlYWNoIHBhcmVudCwgYnV0IHRoYXQgd291bGQgbGVhdmUgdGhpcyBlbnRyeSBpbiBwYXJlbnQuY2hpbGRWYWx1ZXNcbiAgICAgICAgLy8gYW5kIHBhcmVudC5kaXJ0eUNoaWxkcmVuLCB3aGljaCB3b3VsZCBwcmV2ZW50IHRoZSBjaGlsZCBmcm9tIGJlaW5nXG4gICAgICAgIC8vIHRydWx5IGZvcmdvdHRlbi5cbiAgICAgICAgZWFjaFBhcmVudCh0aGlzLCBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50LnNldERpcnR5KCk7XG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIF90aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbnRyeS5wcm90b3R5cGUuZm9yZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGUgY29kZSB0aGF0IGNyZWF0ZXMgRW50cnkgb2JqZWN0cyBpbiBpbmRleC50cyB3aWxsIHJlcGxhY2UgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gd2l0aCBvbmUgdGhhdCBhY3R1YWxseSByZW1vdmVzIHRoZSBFbnRyeSBmcm9tIHRoZSBjYWNoZSwgd2hpY2ggd2lsbCBhbHNvXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGVudHJ5LmRpc3Bvc2UgbWV0aG9kLlxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIEVudHJ5LnByb3RvdHlwZS5kZXBlbmRPbiA9IGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLmFkZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXBzLmFkZChkZXApO1xuICAgIH07XG4gICAgRW50cnkucHJvdG90eXBlLmZvcmdldERlcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRlcHMpIHtcbiAgICAgICAgICAgIGFycmF5RnJvbVNldCh0aGlzLmRlcHMpLmZvckVhY2goZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwLmRlbGV0ZShfdGhpcyk7IH0pO1xuICAgICAgICAgICAgdGhpcy5kZXBzLmNsZWFyKCk7XG4gICAgICAgICAgICBlbXB0eVNldFBvb2wucHVzaCh0aGlzLmRlcHMpO1xuICAgICAgICAgICAgdGhpcy5kZXBzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW50cnkuY291bnQgPSAwO1xuICAgIHJldHVybiBFbnRyeTtcbn0oKSk7XG5mdW5jdGlvbiByZW1lbWJlclBhcmVudChjaGlsZCkge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRFbnRyeVNsb3QuZ2V0VmFsdWUoKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNoaWxkLnBhcmVudHMuYWRkKHBhcmVudCk7XG4gICAgICAgIGlmICghcGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5zZXQoY2hpbGQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlnaHRCZURpcnR5KGNoaWxkKSkge1xuICAgICAgICAgICAgcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFsbHlSZWNvbXB1dGUoZW50cnksIGFyZ3MpIHtcbiAgICBmb3JnZXRDaGlsZHJlbihlbnRyeSk7XG4gICAgLy8gU2V0IGVudHJ5IGFzIHRoZSBwYXJlbnQgZW50cnkgd2hpbGUgY2FsbGluZyByZWNvbXB1dGVOZXdWYWx1ZShlbnRyeSkuXG4gICAgcGFyZW50RW50cnlTbG90LndpdGhWYWx1ZShlbnRyeSwgcmVjb21wdXRlTmV3VmFsdWUsIFtlbnRyeSwgYXJnc10pO1xuICAgIGlmIChtYXliZVN1YnNjcmliZShlbnRyeSwgYXJncykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc3VjY2Vzc2Z1bGx5IHJlY29tcHV0ZWQgZW50cnkudmFsdWUgYW5kIGRpZCBub3QgZmFpbCB0b1xuICAgICAgICAvLyAocmUpc3Vic2NyaWJlLCB0aGVuIHRoaXMgRW50cnkgaXMgbm8gbG9uZ2VyIGV4cGxpY2l0bHkgZGlydHkuXG4gICAgICAgIHNldENsZWFuKGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlR2V0KGVudHJ5LnZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5LCBhcmdzKSB7XG4gICAgZW50cnkucmVjb21wdXRpbmcgPSB0cnVlO1xuICAgIHZhciBub3JtYWxpemVSZXN1bHQgPSBlbnRyeS5ub3JtYWxpemVSZXN1bHQ7XG4gICAgdmFyIG9sZFZhbHVlQ29weTtcbiAgICBpZiAobm9ybWFsaXplUmVzdWx0ICYmIGVudHJ5LnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBvbGRWYWx1ZUNvcHkgPSB2YWx1ZUNvcHkoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICAvLyBNYWtlIGVudHJ5LnZhbHVlIGFuIGVtcHR5IGFycmF5LCByZXByZXNlbnRpbmcgYW4gdW5rbm93biB2YWx1ZS5cbiAgICBlbnRyeS52YWx1ZS5sZW5ndGggPSAwO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIElmIGVudHJ5LmZuIHN1Y2NlZWRzLCBlbnRyeS52YWx1ZSB3aWxsIGJlY29tZSBhIG5vcm1hbCBWYWx1ZS5cbiAgICAgICAgZW50cnkudmFsdWVbMF0gPSBlbnRyeS5mbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZpYWJsZSBvbGRWYWx1ZUNvcHkgdG8gY29tcGFyZSB3aXRoIHRoZSAoc3VjY2Vzc2Z1bGx5XG4gICAgICAgIC8vIHJlY29tcHV0ZWQpIG5ldyBlbnRyeS52YWx1ZSwgYW5kIHRoZXkgYXJlIG5vdCBhbHJlYWR5ID09PSBpZGVudGljYWwsIGdpdmVcbiAgICAgICAgLy8gbm9ybWFsaXplUmVzdWx0IGEgY2hhbmNlIHRvIHBpY2svY2hvb3NlL3JldXNlIHBhcnRzIG9mIG9sZFZhbHVlQ29weVswXVxuICAgICAgICAvLyBhbmQvb3IgZW50cnkudmFsdWVbMF0gdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBjYWNoZWQgZW50cnkudmFsdWUuXG4gICAgICAgIGlmIChub3JtYWxpemVSZXN1bHQgJiYgb2xkVmFsdWVDb3B5ICYmICF2YWx1ZUlzKG9sZFZhbHVlQ29weSwgZW50cnkudmFsdWUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVudHJ5LnZhbHVlWzBdID0gbm9ybWFsaXplUmVzdWx0KGVudHJ5LnZhbHVlWzBdLCBvbGRWYWx1ZUNvcHlbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm9ybWFsaXplUmVzdWx0IHRocm93cywganVzdCB1c2UgdGhlIG5ld2VyIHZhbHVlLCByYXRoZXIgdGhhblxuICAgICAgICAgICAgICAgIC8vIHNhdmluZyB0aGUgZXhjZXB0aW9uIGFzIGVudHJ5LnZhbHVlWzFdLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIGVudHJ5LmZuIHRocm93cywgZW50cnkudmFsdWUgd2lsbCBob2xkIHRoYXQgZXhjZXB0aW9uLlxuICAgICAgICBlbnRyeS52YWx1ZVsxXSA9IGU7XG4gICAgfVxuICAgIC8vIEVpdGhlciB3YXksIHRoaXMgbGluZSBpcyBhbHdheXMgcmVhY2hlZC5cbiAgICBlbnRyeS5yZWNvbXB1dGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gbWlnaHRCZURpcnR5KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmRpcnR5IHx8ICEhKGVudHJ5LmRpcnR5Q2hpbGRyZW4gJiYgZW50cnkuZGlydHlDaGlsZHJlbi5zaXplKTtcbn1cbmZ1bmN0aW9uIHNldENsZWFuKGVudHJ5KSB7XG4gICAgZW50cnkuZGlydHkgPSBmYWxzZTtcbiAgICBpZiAobWlnaHRCZURpcnR5KGVudHJ5KSkge1xuICAgICAgICAvLyBUaGlzIEVudHJ5IG1heSBzdGlsbCBoYXZlIGRpcnR5IGNoaWxkcmVuLCBpbiB3aGljaCBjYXNlIHdlIGNhbid0XG4gICAgICAgIC8vIGxldCBvdXIgcGFyZW50cyBrbm93IHdlJ3JlIGNsZWFuIGp1c3QgeWV0LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcG9ydENsZWFuKGVudHJ5KTtcbn1cbmZ1bmN0aW9uIHJlcG9ydERpcnR5KGNoaWxkKSB7XG4gICAgZWFjaFBhcmVudChjaGlsZCwgcmVwb3J0RGlydHlDaGlsZCk7XG59XG5mdW5jdGlvbiByZXBvcnRDbGVhbihjaGlsZCkge1xuICAgIGVhY2hQYXJlbnQoY2hpbGQsIHJlcG9ydENsZWFuQ2hpbGQpO1xufVxuZnVuY3Rpb24gZWFjaFBhcmVudChjaGlsZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyZW50Q291bnQgPSBjaGlsZC5wYXJlbnRzLnNpemU7XG4gICAgaWYgKHBhcmVudENvdW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRzID0gYXJyYXlGcm9tU2V0KGNoaWxkLnBhcmVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmVudHNbaV0sIGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIExldCBhIHBhcmVudCBFbnRyeSBrbm93IHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbiBtYXkgYmUgZGlydHkuXG5mdW5jdGlvbiByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICAvLyBNdXN0IGhhdmUgY2FsbGVkIHJlbWVtYmVyUGFyZW50KGNoaWxkKSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkuXG4gICAgYXNzZXJ0KHBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKTtcbiAgICBhc3NlcnQobWlnaHRCZURpcnR5KGNoaWxkKSk7XG4gICAgdmFyIHBhcmVudFdhc0NsZWFuID0gIW1pZ2h0QmVEaXJ0eShwYXJlbnQpO1xuICAgIGlmICghcGFyZW50LmRpcnR5Q2hpbGRyZW4pIHtcbiAgICAgICAgcGFyZW50LmRpcnR5Q2hpbGRyZW4gPSBlbXB0eVNldFBvb2wucG9wKCkgfHwgbmV3IFNldDtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50LmRpcnR5Q2hpbGRyZW4uaGFzKGNoaWxkKSkge1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhpcyBjaGlsZCBpcyBkaXJ0eSwgdGhlbiB3ZSBtdXN0IGhhdmUgYWxyZWFkeVxuICAgICAgICAvLyBpbmZvcm1lZCBvdXIgb3duIHBhcmVudHMgdGhhdCB3ZSBhcmUgZGlydHksIHNvIHdlIGNhbiB0ZXJtaW5hdGVcbiAgICAgICAgLy8gdGhlIHJlY3Vyc2lvbiBlYXJseS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnQuZGlydHlDaGlsZHJlbi5hZGQoY2hpbGQpO1xuICAgIC8vIElmIHBhcmVudCB3YXMgY2xlYW4gYmVmb3JlLCBpdCBqdXN0IGJlY2FtZSAocG9zc2libHkpIGRpcnR5IChhY2NvcmRpbmcgdG9cbiAgICAvLyBtaWdodEJlRGlydHkpLCBzaW5jZSB3ZSBqdXN0IGFkZGVkIGNoaWxkIHRvIHBhcmVudC5kaXJ0eUNoaWxkcmVuLlxuICAgIGlmIChwYXJlbnRXYXNDbGVhbikge1xuICAgICAgICByZXBvcnREaXJ0eShwYXJlbnQpO1xuICAgIH1cbn1cbi8vIExldCBhIHBhcmVudCBFbnRyeSBrbm93IHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbiBpcyBubyBsb25nZXIgZGlydHkuXG5mdW5jdGlvbiByZXBvcnRDbGVhbkNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICAvLyBNdXN0IGhhdmUgY2FsbGVkIHJlbWVtYmVyQ2hpbGQoY2hpbGQpIGJlZm9yZSBjYWxsaW5nXG4gICAgLy8gcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKS5cbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xuICAgIGFzc2VydCghbWlnaHRCZURpcnR5KGNoaWxkKSk7XG4gICAgdmFyIGNoaWxkVmFsdWUgPSBwYXJlbnQuY2hpbGRWYWx1ZXMuZ2V0KGNoaWxkKTtcbiAgICBpZiAoY2hpbGRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgdmFsdWVDb3B5KGNoaWxkLnZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF2YWx1ZUlzKGNoaWxkVmFsdWUsIGNoaWxkLnZhbHVlKSkge1xuICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICB9XG4gICAgcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICBpZiAobWlnaHRCZURpcnR5KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBvcnRDbGVhbihwYXJlbnQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgdmFyIGRjID0gcGFyZW50LmRpcnR5Q2hpbGRyZW47XG4gICAgaWYgKGRjKSB7XG4gICAgICAgIGRjLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgIGlmIChkYy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZW1wdHlTZXRQb29sLmxlbmd0aCA8IFBPT0xfVEFSR0VUX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBlbXB0eVNldFBvb2wucHVzaChkYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZGlydHlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgZW50cnkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlXG4vLyByZW1vdmVkIGNoaWxkcmVuLlxuZnVuY3Rpb24gZm9yZ2V0Q2hpbGRyZW4ocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5jaGlsZFZhbHVlcy5zaXplID4gMCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBjaGlsZCkge1xuICAgICAgICAgICAgZm9yZ2V0Q2hpbGQocGFyZW50LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhpcyBwYXJlbnQgRW50cnkgZnJvbSBhbnkgc2V0cyB0byB3aGljaCBpdCB3YXMgYWRkZWQgYnkgdGhlXG4gICAgLy8gYWRkVG9TZXQgbWV0aG9kLlxuICAgIHBhcmVudC5mb3JnZXREZXBzKCk7XG4gICAgLy8gQWZ0ZXIgd2UgZm9yZ2V0IGFsbCBvdXIgY2hpbGRyZW4sIHRoaXMuZGlydHlDaGlsZHJlbiBtdXN0IGJlIGVtcHR5XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBtdXN0IGhhdmUgYmVlbiByZXNldCB0byBudWxsLlxuICAgIGFzc2VydChwYXJlbnQuZGlydHlDaGlsZHJlbiA9PT0gbnVsbCk7XG59XG5mdW5jdGlvbiBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50cy5kZWxldGUocGFyZW50KTtcbiAgICBwYXJlbnQuY2hpbGRWYWx1ZXMuZGVsZXRlKGNoaWxkKTtcbiAgICByZW1vdmVEaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gbWF5YmVTdWJzY3JpYmUoZW50cnksIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVudHJ5LnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGVudHJ5KTsgLy8gUHJldmVudCBkb3VibGUgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZW50cnkuc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIEVudHJ5IGhhcyBhIHN1YnNjcmliZSBmdW5jdGlvbiBhbmQgaXQgdGhyZXcgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyAob3IgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gaXQgcHJldmlvdXNseSByZXR1cm5lZCBub3cgdGhyb3dzKSxcbiAgICAgICAgICAgIC8vIHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdlIHdlcmUgbm90IGFibGUgdG8gc3Vic2NyaWJlIChvclxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUpLCBhbmQgdGhpcyBFbnRyeSBzaG91bGQgcmVtYWluIGRpcnR5LlxuICAgICAgICAgICAgZW50cnkuc2V0RGlydHkoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5pbmcgdHJ1ZSBpbmRpY2F0ZXMgZWl0aGVyIHRoYXQgdGhlcmUgd2FzIG5vIGVudHJ5LnN1YnNjcmliZVxuICAgIC8vIGZ1bmN0aW9uIG9yIHRoYXQgaXQgc3VjY2VlZGVkLlxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgRW50cnlNZXRob2RzID0ge1xuICAgIHNldERpcnR5OiB0cnVlLFxuICAgIGRpc3Bvc2U6IHRydWUsXG4gICAgZm9yZ2V0OiB0cnVlLCAvLyBGdWxseSByZW1vdmUgcGFyZW50IEVudHJ5IGZyb20gTFJVIGNhY2hlIGFuZCBjb21wdXRhdGlvbiBncmFwaFxufTtcbmZ1bmN0aW9uIGRlcChvcHRpb25zKSB7XG4gICAgdmFyIGRlcHNCeUtleSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgc3Vic2NyaWJlID0gb3B0aW9ucyAmJiBvcHRpb25zLnN1YnNjcmliZTtcbiAgICBmdW5jdGlvbiBkZXBlbmQoa2V5KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRFbnRyeVNsb3QuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGRlcF8xID0gZGVwc0J5S2V5LmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFkZXBfMSkge1xuICAgICAgICAgICAgICAgIGRlcHNCeUtleS5zZXQoa2V5LCBkZXBfMSA9IG5ldyBTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmRlcGVuZE9uKGRlcF8xKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGRlcF8xKTtcbiAgICAgICAgICAgICAgICBkZXBfMS51bnN1YnNjcmliZSA9IHN1YnNjcmliZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlcGVuZC5kaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGtleSwgZW50cnlNZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBkZXAgPSBkZXBzQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgIGlmIChkZXApIHtcbiAgICAgICAgICAgIHZhciBtXzEgPSAoZW50cnlNZXRob2ROYW1lICYmXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChFbnRyeU1ldGhvZHMsIGVudHJ5TWV0aG9kTmFtZSkpID8gZW50cnlNZXRob2ROYW1lIDogXCJzZXREaXJ0eVwiO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgYXJyYXlGcm9tU2V0KGRlcCkuZm9yRWFjaCBpbnN0ZWFkIG9mIGRlcC5mb3JFYWNoLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtb2RpZnlpbmcgYSBTZXQgd2hpbGUgaXRlcmF0aW5nIG92ZXIgaXQgY2FuIGNhdXNlIGVsZW1lbnRzIGluXG4gICAgICAgICAgICAvLyB0aGUgU2V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgU2V0IGJlZm9yZSB0aGV5J3ZlIGJlZW4gaXRlcmF0ZWQgb3Zlci5cbiAgICAgICAgICAgIGFycmF5RnJvbVNldChkZXApLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeVttXzFdKCk7IH0pO1xuICAgICAgICAgICAgZGVwc0J5S2V5LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgbWF5YmVVbnN1YnNjcmliZShkZXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVwZW5kO1xufVxuXG4vLyBUaGUgZGVmYXVsdE1ha2VDYWNoZUtleSBmdW5jdGlvbiBpcyByZW1hcmthYmx5IHBvd2VyZnVsLCBiZWNhdXNlIGl0IGdpdmVzXG4vLyBhIHVuaXF1ZSBvYmplY3QgZm9yIGFueSBzaGFsbG93LWlkZW50aWNhbCBsaXN0IG9mIGFyZ3VtZW50cy4gSWYgeW91IG5lZWRcbi8vIHRvIGltcGxlbWVudCBhIGN1c3RvbSBtYWtlQ2FjaGVLZXkgZnVuY3Rpb24sIHlvdSBtYXkgZmluZCBpdCBoZWxwZnVsIHRvXG4vLyBkZWxlZ2F0ZSB0aGUgZmluYWwgd29yayB0byBkZWZhdWx0TWFrZUNhY2hlS2V5LCB3aGljaCBpcyB3aHkgd2UgZXhwb3J0IGl0XG4vLyBoZXJlLiBIb3dldmVyLCB5b3UgbWF5IHdhbnQgdG8gYXZvaWQgZGVmYXVsdE1ha2VDYWNoZUtleSBpZiB5b3VyIHJ1bnRpbWVcbi8vIGRvZXMgbm90IHN1cHBvcnQgV2Vha01hcCwgb3IgeW91IGhhdmUgdGhlIGFiaWxpdHkgdG8gcmV0dXJuIGEgc3RyaW5nIGtleS5cbi8vIEluIHRob3NlIGNhc2VzLCBqdXN0IHdyaXRlIHlvdXIgb3duIGN1c3RvbSBtYWtlQ2FjaGVLZXkgZnVuY3Rpb25zLlxudmFyIGRlZmF1bHRLZXlUcmllO1xuZnVuY3Rpb24gZGVmYXVsdE1ha2VDYWNoZUtleSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHRyaWUkMSA9IGRlZmF1bHRLZXlUcmllIHx8IChkZWZhdWx0S2V5VHJpZSA9IG5ldyB0cmllLlRyaWUodHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIikpO1xuICAgIHJldHVybiB0cmllJDEubG9va3VwQXJyYXkoYXJncyk7XG59XG52YXIgY2FjaGVzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd3JhcChvcmlnaW5hbEZ1bmN0aW9uLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogX2EsIF9jID0gX2IubWF4LCBtYXggPSBfYyA9PT0gdm9pZCAwID8gTWF0aC5wb3coMiwgMTYpIDogX2MsIGtleUFyZ3MgPSBfYi5rZXlBcmdzLCBfZCA9IF9iLm1ha2VDYWNoZUtleSwgbWFrZUNhY2hlS2V5ID0gX2QgPT09IHZvaWQgMCA/IGRlZmF1bHRNYWtlQ2FjaGVLZXkgOiBfZCwgbm9ybWFsaXplUmVzdWx0ID0gX2Iubm9ybWFsaXplUmVzdWx0LCBzdWJzY3JpYmUgPSBfYi5zdWJzY3JpYmUsIF9lID0gX2IuY2FjaGUsIGNhY2hlT3B0aW9uID0gX2UgPT09IHZvaWQgMCA/IGNhY2hlcyQxLlN0cm9uZ0NhY2hlIDogX2U7XG4gICAgdmFyIGNhY2hlID0gdHlwZW9mIGNhY2hlT3B0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBuZXcgY2FjaGVPcHRpb24obWF4LCBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmRpc3Bvc2UoKTsgfSlcbiAgICAgICAgOiBjYWNoZU9wdGlvbjtcbiAgICB2YXIgb3B0aW1pc3RpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBrZXlBcmdzID8ga2V5QXJncy5hcHBseShudWxsLCBhcmd1bWVudHMpIDogYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBlbnRyeSA9IG5ldyBFbnRyeShvcmlnaW5hbEZ1bmN0aW9uKSk7XG4gICAgICAgICAgICBlbnRyeS5ub3JtYWxpemVSZXN1bHQgPSBub3JtYWxpemVSZXN1bHQ7XG4gICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgICAgICAvLyBHaXZlIHRoZSBFbnRyeSB0aGUgYWJpbGl0eSB0byB0cmlnZ2VyIGNhY2hlLmRlbGV0ZShrZXkpLCBldmVuIHRob3VnaFxuICAgICAgICAgICAgLy8gdGhlIEVudHJ5IGl0c2VsZiBkb2VzIG5vdCBrbm93IGFib3V0IGtleSBvciBjYWNoZS5cbiAgICAgICAgICAgIGVudHJ5LmZvcmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlLmRlbGV0ZShrZXkpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LnJlY29tcHV0ZShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgLy8gTW92ZSB0aGlzIGVudHJ5IHRvIHRoZSBmcm9udCBvZiB0aGUgbGVhc3QtcmVjZW50bHkgdXNlZCBxdWV1ZSxcbiAgICAgICAgLy8gc2luY2Ugd2UganVzdCBmaW5pc2hlZCBjb21wdXRpbmcgaXRzIHZhbHVlLlxuICAgICAgICBjYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgIGNhY2hlcy5hZGQoY2FjaGUpO1xuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgZXhjZXNzIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBidXQgb25seSBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBhY3RpdmUgcGFyZW50IGVudHJ5LCBtZWFuaW5nIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGEgbGFyZ2VyXG4gICAgICAgIC8vIGNvbXB1dGF0aW9uIHRoYXQgbWlnaHQgYmUgZmx1bW1veGVkIGJ5IHRoZSBjbGVhbmluZy5cbiAgICAgICAgaWYgKCFwYXJlbnRFbnRyeVNsb3QuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY2FjaGVzLmZvckVhY2goZnVuY3Rpb24gKGNhY2hlKSB7IHJldHVybiBjYWNoZS5jbGVhbigpOyB9KTtcbiAgICAgICAgICAgIGNhY2hlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpbWlzdGljLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlLnNpemU7IH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5mcmVlemUob3B0aW1pc3RpYy5vcHRpb25zID0ge1xuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAga2V5QXJnczoga2V5QXJncyxcbiAgICAgICAgbWFrZUNhY2hlS2V5OiBtYWtlQ2FjaGVLZXksXG4gICAgICAgIG5vcm1hbGl6ZVJlc3VsdDogbm9ybWFsaXplUmVzdWx0LFxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGRpcnR5S2V5KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXkgJiYgY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgZW50cnkuc2V0RGlydHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHRpbWlzdGljLmRpcnR5S2V5ID0gZGlydHlLZXk7XG4gICAgb3B0aW1pc3RpYy5kaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KCkge1xuICAgICAgICBkaXJ0eUtleShtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwZWVrS2V5KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXkgJiYgY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnBlZWsoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHRpbWlzdGljLnBlZWtLZXkgPSBwZWVrS2V5O1xuICAgIG9wdGltaXN0aWMucGVlayA9IGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiBwZWVrS2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvcmdldEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGNhY2hlLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIG9wdGltaXN0aWMuZm9yZ2V0S2V5ID0gZm9yZ2V0S2V5O1xuICAgIG9wdGltaXN0aWMuZm9yZ2V0ID0gZnVuY3Rpb24gZm9yZ2V0KCkge1xuICAgICAgICByZXR1cm4gZm9yZ2V0S2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIG9wdGltaXN0aWMubWFrZUNhY2hlS2V5ID0gbWFrZUNhY2hlS2V5O1xuICAgIG9wdGltaXN0aWMuZ2V0S2V5ID0ga2V5QXJncyA/IGZ1bmN0aW9uIGdldEtleSgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBrZXlBcmdzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH0gOiBtYWtlQ2FjaGVLZXk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob3B0aW1pc3RpYyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnS2V5VHJpZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJpZS5UcmllOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2xvdCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGV4dC5TbG90OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYXN5bmNGcm9tR2VuJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LmFzeW5jRnJvbUdlbjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2JpbmRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LmJpbmQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdub0NvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHQubm9Db250ZXh0OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2V0VGltZW91dCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGV4dC5zZXRUaW1lb3V0OyB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdE1ha2VDYWNoZUtleSA9IGRlZmF1bHRNYWtlQ2FjaGVLZXk7XG5leHBvcnRzLmRlcCA9IGRlcDtcbmV4cG9ydHMubm9uUmVhY3RpdmUgPSBub25SZWFjdGl2ZTtcbmV4cG9ydHMud3JhcCA9IHdyYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/optimism/lib/bundle.cjs\n");

/***/ })

};
;